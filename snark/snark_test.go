package snark

import (
	"encoding/hex"
	"log"
	"testing"
)

func split(buf []byte, lim int) [][]byte {
	var chunk []byte
	chunks := make([][]byte, 0, len(buf)/lim+1)
	for len(buf) >= lim {
		chunk, buf = buf[:lim], buf[lim:]
		chunks = append(chunks, chunk)
	}
	if len(buf) > 0 {
		chunks = append(chunks, buf[:len(buf)])
	}
	return chunks
}

func TestVerify(t *testing.T) {
	proof := "2d687f19a50a9fa448f0b8fe66fdebef79fcf7aa3a28dbe99b3cf9c9b5ccbd8e3112e70f6adc6dbd1f7842ce8c979a8df231913885c1f49c4d7a5061cc86818eb0236aed6ac7249771d52d5c4afb9786594ac90e85ce74baf3e03d2b4486558041504a292703a08bb354d3a72d6833eadcfc0091a2485c28eb276fe9db1db7f3a556f43d4653644c4d674cfeb404746b96e0b4319c509275a833e4b74994c2cd577b24cc69f8c8d1878d198bcce0d859c08b123d79ad55f5e79d5c9187a0e68012d9d0ceb60bc128699eadeca80b4aa64975bc2362903b5c5962fe3e206b099ef94d47c2855c147e47ad504615bc296d69c45fe5d9919dd9461ee35d0d444a2b3f70c88d9ee94162357fbef002826cf5d107bc2840a7f5a4fadd012ca5c84700"
	vk := "cb08a9edbe0d663c0b974db1e10214a3a1360c43b24965ec1ccec41a3b71bb68970ea85fcced35eb96a513fe9d331c78aeac9876a836d5ea5979d0fe8df90e1df97935983d5c8a98a0fd4b0674817ed93a446e283c6e46cd5516040bc53f1681a80f0158393d08d12c3585162db176da7abdcd88c19030101f63803284c87ab12d19e4327887f5f895142a2b1bce30f7fbfeb183aacb39932c9273222b6a682c614d9f0863b2675d4f5a8cec5324ee7f36601c1bd0cc5324449498664d77ee006320fa22379f656182343cb1271411f2beb6a5cedb09108769058b3ce866f95c320bf6a47a35c9be80f4f2c3eb25f12fbeeeca87d469dab31cbc2319f7a33d8a49ad54a7d18f4a5c67776888a616886440c4d2f385a25340e4aa445d04dbb80024b2dae75842cd9bd079ddf5e3c4fac428e3c26341fc6ab9dc781dce7099f0ea9270a6c8d5ae327e003351bfa24983fe12c0ec6a810d54b921bcf249942ff8920d852eb9a48cf4f40da2eb26ee3bc341665820b30d88a30558b232237659860003000000000000000c5108166bb171dfc32916917d28f54f2bac7dae9d66ba6e0ac2da6e288d19e033964ba7fe020f93fe0d43dddcf340f7085280216890b70ba3c1f534d1575090a57597ab507a178dd48188a5b439ac6734b1636efba3ff29e5eb32a2a8857c8070bcb52afe7a1d7b2a7726564c31b12a58f21bc0712a236a3883b531189b4f27a20e05e419c5b41b0ecd4f8d3361f62fae6a087541fefd687a5760fc21291accd0ca27caa60237bee8b513acd1a9aa374edb5ffa08bb8150f761166e23f2f980a7e9e08c7acc5427c7b073f6710d380b06dafe912c5711f679e1dc4aae84a43c329e3ca35b35a7c288681d0d864658d5e117641773f513512cf8dd320898033a965d7632ad13881aa9591159deaff218ca980b3e9e8c71b84462789501712a80"
	first_epoch_pubkeys := "c9739cc7138839932a0242198c9010931d637e12ef14a721f5c899a931b9f4768cf99d7b2dd1e4155d84c445b6e35f0098e50851f002ce88e54ed9e85585c9734e7e9a5ad62ce9c31bd9bfc07d8e05966672991b41c975eb18b0016a54b872807f34bc397312f9fec5bf4b54a3d7d109e24e7d8ebc767a1650fc7d0499a9b4b63803e4339e411ecae3a7a3c807c9de00bc04db8dfc67ca24a076ea89c527d3728a4303a0730d5e9eaa62c0ddfd7ca60f3ef3c40d822e925deaa4de618add7181401a944e07a02fececa63b80dc599f55dd3f3bb3694397a53d4ba966e1fd855a5869995066e1305c56d80df5d22a1800c4532a8a2e4ed60cdfcba9656e31f1f2f4995d7455728ce345bace27bf82b83cb52895c03c242c1f81762074b6b338013a640d0ef661b36b7c1d16bb0db7b504ad56849e462ec2f2fb6e634a2ecf97b5973061fcc9793bbd4196e8e43aa11a01f390ff5210a56c58488abb85f25306034c4b254379fac8694627a93d8464e48c87f8f562080b5484e3fa81bb28dc0880"
	last_epoch_pubkeys := "3e2b12102137fb22b4090758fa401402c38395ccb298b0293ce92aae1b0ee94dca8f584f3711f9215e09956675db23018b096ef962d45776b1b2297659f72654718d9c966992de74603e6a4b4f9a772593fb7eee81c80172bcc066f602356700f71a26d968d8d72879a545f23b786d77647651ac4d53664c5c1fa4bd12ce361b7c9453977bed702dd47a7e60163929010874597b5c576e5f0833f6e0eed0ef092b390a5e603c119e31b959abb0da91dfb9f8f261beaaaedb1174aa52792bc3008aae6c635b6d8928242bed6b6a9593997b37592f9d9979243089585a882b2a487d94619b4034296b9b1342ab4db69300923962be630dfafef037b7396b8def0334f350b74c0ffa7b87fc376512c3b3bb49c14e7999f7245debac1a6b5b5b8b8154565226aff2d54773d5f319a4d9d3122fabbeee1236aee23584b2f4c74049b70f4813a08938e6536df886ddca3691001b7225731da891b5491530d818168bd953a9b7abdbb55881e4001acbc92a03c55c26535e5966e16dab9b387e89f58801"

	epoch1EpochEntropy := make([]byte, 16)
	epoch1ParentEntropy := make([]byte, 16)
	for i := 0; i < 16; i++ {
		epoch1EpochEntropy[i] = 1
		epoch1ParentEntropy[i] = 2
	}

	pk1, _ := hex.DecodeString(first_epoch_pubkeys)
	publicKeys := split(pk1, PUBLIC_KEY_BYTES)
	epoch1 := EpochBlock{
		Index:         0,
		MaxNonSigners: 1,
		MaxValidators: uint(len(publicKeys)),
		EpochEntropy: epoch1EpochEntropy,
		ParentEntropy: epoch1ParentEntropy,
		PublicKeys:    publicKeys,
	}

	epoch2EpochEntropy := make([]byte, 16)
	epoch2ParentEntropy := make([]byte, 16)
	for i := 0; i < 16; i++ {
		epoch2EpochEntropy[i] = 3
		epoch2ParentEntropy[i] = 2
	}

	pk2, _ := hex.DecodeString(last_epoch_pubkeys)
	epoch2 := EpochBlock{
		Index:         2,
		MaxNonSigners: 1,
		MaxValidators: uint(len(publicKeys)),
		EpochEntropy: epoch2EpochEntropy,
		ParentEntropy: epoch2ParentEntropy,
		PublicKeys:    split(pk2, PUBLIC_KEY_BYTES),
	}

	proofDec, _ := hex.DecodeString(proof)
	vkDec, _ := hex.DecodeString(vk)

	err := VerifyEpochs(
		vkDec,
		proofDec,
		epoch1,
		epoch2,
	)

	if err != nil {
		log.Fatal(err)
	}
}
